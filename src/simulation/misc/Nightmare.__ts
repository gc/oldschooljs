import Minigame from '../../structures/Minigame';
import { addArrayOfNumbers, randFloat, roll, JSONClone, rand } from '../../util/util';
import LootTable from '../../structures/LootTable';
import { ReturnedLootItem, ItemBank, SimpleTableItem, LootBank } from '../../meta/types';
import Loot from '../../structures/Loot';
import { resolveNameBank } from '../../util/bank';
import SimpleTable from '../../structures/SimpleTable';
import itemID from '../../util/itemID';
import { calcPercentOfNum, Time } from 'e';

export interface TeamMember {
	id: string;
	damageDone: number;
}

export interface NightmareOptions {
	/**
	 * The members of the raid team, can be only 1 person.
	 */
	team: TeamMember[];
}

const data: Record<string, [number[], number]> = {
	// Runes and ammunition
	'Cosmic rune': [[15, 214], 4],
	'Nature rune': [[6, 138], 4],
	'Death rune': [[24, 165], 4],
	'Blood rune': [[13, 129], 4],
	'Soul rune': [[12, 74], 4],
	'Adamant arrow': [[32, 488], 3],
	'Rune arrow': [[12, 515], 3],

	// Resources
	'Yew logs': [[14, 111], 4],
	'Magic logs': [[3, 50], 4],
	'Gold ore': [[14, 79], 4],
	Coal: [[16, 253], 4],
	'Mithril ore': [[15, 69], 4],
	'Adamantite ore': [[8, 50], 4],
	'Grimy cadantine': [[1, 8], 4],
	'Grimy torstol': [[1, 16], 4],
	'Uncut emerald': [[1, 26], 3],
	'Uncut ruby': [[2, 35], 3],
	'Pure essence': [[420, 3280], 2],

	// Consumables
	Shark: [[1, 15], 6],
	Bass: [[1, 18], 6],
	'Prayer potion(3)': [[2, 10], 5],
	'Saradomin brew(3)': [[1, 10], 5],
	'Zamorak brew(3)': [[1, 8], 5],
	'Sanfew serum(3)': [[1, 11], 5],

	Coins: [[2717, 41_575], 2]
};
const nonUniqueItemRanges = resolveNameBank(data);

const NonUniqueTable = new SimpleTable<number>();
for (const [id, data] of Object.entries(nonUniqueItemRanges)) {
	NonUniqueTable.add(id, data[1]);
}

const GearTable = new LootTable()
	.add("Inquisitor's mace")
	.add("Inquisitor's great helm", 1, 2)
	.add("Inquisitor's hauberk", 1, 2)
	.add("Inquisitor's plateskirt", 1, 2)
	.add('Nightmare staff', 1, 3);

const OrbTable = new LootTable()
	.add('Eldritch orb')
	.add('Volatile orb')
	.add('Harmonised orb');

const mvpTertiary = new LootTable()
	.tertiary(190, 'Clue scroll (elite)')
	.tertiary(1900, 'Jar of dreams')
	.tertiary(3800, 'Little nightmare');

const nonMvpTertiary = new LootTable()
	.tertiary(200, 'Clue scroll (elite)')
	.tertiary(2000, 'Jar of dreams')
	.tertiary(4000, 'Little nightmare');

class NightmareClass {
	public rollNonUniqueLoot(percentage: number, isMvp: boolean): ItemBank {
		const { item } = NonUniqueTable.roll();

		const [range] = nonUniqueItemRanges[item];
		let quantity = range[0];
		quantity += rand(0, calcPercentOfNum(percentage, range[1]));
		if (isMvp) quantity *= 1.1;

		return {
			[item]: quantity
		};
	}

	public kill(
		_options: NightmareOptions
	): {
		[key: string]: ItemBank;
	} {
		const options = JSONClone(_options);

		const mvp = options.team.sort((a, b) => b.damageDone - a.damageDone)[0];

		const lootResult: LootBank = {};

		if (roll(120)) {
		}

		if (roll(600)) {
		}

		// This table is used to pick which team member gets the unique(s).
		const uniqueDeciderTable = new SimpleTable<string>();

		for (const teamMember of options.team) {
			// Give every team member a Loot.
			lootResult[teamMember.id] = new Loot();

			// Add this member to the "unique decider table", using their points as the weight.
			uniqueDeciderTable.add(teamMember.id, teamMember.damageDone);
		}

		// For every unique item received, add it to someones loot.
		for (const uniqueItem of uniqueLoot) {
			if (uniqueDeciderTable.table.length === 0) break;
			const receipientID = uniqueDeciderTable.roll().item;
			lootResult[receipientID].add(uniqueItem);
			uniqueDeciderTable.delete(receipientID);
		}

		// For everyone who didn't receive a unique, i.e wasn't removed from the
		// unique decider table, give them a non-unique roll.
		for (const leftOverRecipient of uniqueDeciderTable.table) {
			// Find this member in the team, and get their points.
			const pointsOfThisMember = options.team.find(
				member => member.id === leftOverRecipient.item
			).personalPoints;

			const entries = Object.entries(this.rollNonUniqueLoot(pointsOfThisMember));
			for (const [itemID, quantity] of entries) {
				lootResult[leftOverRecipient.item].add(parseInt(itemID), quantity);
			}
		}

		// Convert everyones loot to ItemBanks.
		const result: { [key: string]: ItemBank } = {};
		for (const [id, loot] of Object.entries(lootResult)) {
			result[id] = loot.values();
		}

		return result;
	}
}

const Nightmare = new NightmareClass();
export default Nightmare;
